import matplotlib.pyplot as plt
import numpy as np

from bluemira.base.constants import MU_0_2PI
from bluemira.base.designer import Designer
from bluemira.base.look_and_feel import bluemira_print
from bluemira.base.parameter_frame import ParameterFrame
from bluemira.geometry.wire import BluemiraWire
from bluemira.magnets.cable import RectangularCable
from bluemira.magnets.case_tf import TrapezoidalCaseTF
from bluemira.magnets.conductor import SymmetricConductor
from bluemira.magnets.utils import delayed_exp_func
from bluemira.magnets.winding_pack import WindingPack
from bluemira.utilities.tools import get_class_from_module


class WindingPackDesignerParams(ParameterFrame):
    R0 = 8.6  # [m] major machine radius
    B0 = 4.39  # [T] magnetic field @R0
    A = 2.8  # machine aspect ratio
    n_TF = 16  # number of TF coils
    ripple = 6e-3  # requirement on the maximum plasma ripple
    a = R0 / A  # minor radius
    d = 1.82  # additional distance to calculate the max external radius of the inner TF leg
    operational_current = 70.0e3  # operational current in each conductor
    T_sc = 4.2  # operational temperature of superconducting cable
    T_margin = 1.5  # temperature margin
    t_delay = 3  # [s]
    t0 = 0  # [s]
    hotspot_target_temperature = 250.0  # [K]
    R_VV = Ri * 1.05  # Vacuum vessel radius
    S_VV = 100e6  # Vacuum vessel steel limit
    d_strand_sc = 1.0e-3
    d_strand_stab = 1.0e-3

    # allowable stress values
    safety_factor = 1.5 * 1.3

    dx = 0.05  # cable length... just a dummy value
    B_ref = 15  # [T] Reference B field value (limit for LTS)


def B_TF_r(tf_current, n_TF, r):
    """
    Compute the magnetic field generated by the TF coils, including ripple correction.

    Parameters
    ----------
    tf_current : float
        Toroidal field coil current [A].
    n_TF : int
        Number of toroidal field coils.
    r : float
        Radial position from the tokamak center [m].

    Returns
    -------
    float
        Magnetic field intensity [T].
    """
    return 1.08 * (MU_0_2PI * n_TF * tf_current / r)


class WindingPackDesigner(Designer[BluemiraWire]):
    def run(self) -> BluemiraWire:
        dr_plasma_side = R0 * 2 / 3 * 1e-2  # thickness of the plate before the WP
        Ri = R0 - a - d  # [m] max external radius of the internal TF leg

        # [m] max internal radius of the external TF leg
        Re = (R0 + a) * (1 / ripple) ** (1 / n_TF)
        total_tf_current = B0 * R0 / MU_0_2PI / n_TF  # total current in each TF coil

        # max magnetic field on the inner TF leg

        B_TF_i = B_TF_r(total_tf_current, n_TF, Ri)

        # magnetic pressure on the inner TF leg
        pm = B_TF_i**2 / (2 * MU_0)

        # vertical tension acting on the equatorial section of inner TF leg
        # i.e. half of the whole F_Z
        t_z = 0.5 * np.log(Re / Ri) * MU_0_4PI * n_TF * total_tf_current**2

        n_cond = np.floor(
            total_tf_current / operational_current
        )  # minimum number of conductors
        bluemira_print(f"Total number of conductor: {n_cond}")
        S_Y = 1e9 / safety_factor  # [Pa] steel allowable limit

        # inductance (here approximated... better estimation in bluemira)
        L = (
            MU_0
            * R0
            * (n_TF * n_cond) ** 2
            * (1 - np.sqrt(1 - (R0 - Ri) / R0))
            / n_TF
            * 1.1
        )
        # Magnetic energy
        Wm = 1 / 2 * L * n_TF * operational_current**2 * 1e-9
        # Maximum tension... (empirical formula from Lorenzo... find a generic equation)
        V_MAX = (7 * R0 - 3) / 6 * 1.1e3
        # Discharge characteristic time to be considered in the following
        tau_discharge = max([
            L * operational_current / V_MAX,
            B0 * total_tf_current * n_TF * (R0 / A) ** 2 / (R_VV * S_VV),
        ])
        tf = tau_discharge
        bluemira_print(f"Maximum TF discharge time: {tau_discharge}")

        I_fun = delayed_exp_func(operational_current, tau_discharge, t_delay)
        B_fun = delayed_exp_func(B_TF_i, tau_discharge, t_delay)

        # Create a time array from 0 to 3*tau_discharge
        t = np.linspace(0, 3 * tau_discharge, 500)
        I_data = np.array([I_fun(t_i) for t_i in t])
        B_data = np.array([B_fun(t_i) for t_i in t])
        T_op = T_sc + T_margin  # temperature considered for the superconducting cable

        stab_strand_config = self.build_config.get("stabilising_strand")
        stab_strand_cls = get_class_from_module(stab_strand_config["class"])
        stab_strand = stab_strand_cls(
            name=stab_strand_config.get("name"),
            d_strand=self.params.d_strand_stab,
            temperature=T_op,
            material=stab_strand_config.get("material"),
        )

        sc_strand_config = self.build_config.get("superconducting_strand")
        sc_strand_cls = get_class_from_module(sc_strand_config["class"])
        sc_strand = sc_strand_cls(
            name=sc_strand_config.get("name"),
            d_strand=self.params.d_strand_sc,
            temperature=T_op,
            material=sc_strand_config.get("material"),
        )

        Ic_sc = sc_strand.Ic(B=B_TF_i, temperature=(T_op))
        n_sc_strand = int(np.ceil(operational_current / Ic_sc))

        if B_TF_i < B_ref:
            name = cable_name + "LTS"
            E = 0.1e9
        else:
            name = cable_name + "HTS"
            E = 120e9

        cable = RectangularCable(
            name,
            dx,
            sc_strand=sc_strand,
            stab_strand=stab_strand,
            n_sc_strand=n_sc_strand,
            n_stab_strand=500,
            d_cooling_channel=1e-2,
            void_fraction=0.7,
            cos_theta=0.97,
            E=E,
        )

        T_for_hts = T_op
        cable_out = cable.optimise_n_stab_ths(
            t0,
            tf,
            T_for_hts,
            hotspot_target_temperature,
            B_fun,
            I_fun,
            bounds=[1, 10000],
        )
        conductor = SymmetricConductor(
            cable=cable_out,
            mat_jacket=ss316,
            mat_ins=dummy_insulator,
            dx_jacket=0.01,
            dx_ins=1e-3,
        )
        winding_pack = WindingPack(
            conductor, 1, 1, name=None
        )  # just a dummy WP to create the case
        case = TrapezoidalCaseTF(
            Ri=Ri,
            dy_ps=dr_plasma_side,
            dy_vault=0.7,
            theta_TF=360 / n_TF,
            mat_case=ss316,
            WPs=[winding_pack],
        )
        conductor_arrangement = case.rearrange_conductors_in_wp(
            n_conductors=n_cond,
            wp_reduction_factor=wp_reduction_factor,
            min_gap_x=min_gap_x,
            n_layers_reduction=n_layers_reduction,
            layout=layout,
        )
        case_out = case.optimise_jacket_and_vault(
            pm=pm,
            fz=t_z,
            temperature=T_op,
            B=B_TF_i,
            allowable_sigma=S_Y,
            bounds_cond_jacket=bounds_cond_jacket,
            bounds_dy_vault=bounds_dy_vault,
            layout=layout,
            wp_reduction_factor=wp_reduction_factor,
            min_gap_x=min_gap_x,
            n_layers_reduction=n_layers_reduction,
            max_niter=max_niter,
            eps=err,
            n_conds=n_cond,
        )


def plot_cable_temperature_evolution(result, t0, tf, ax, n_steps=100):
    solution = result.solution

    ax.plot(solution.t, solution.y[0], "r*", label="Simulation points")
    time_steps = np.linspace(t0, tf, n_steps)
    ax.plot(time_steps, solution.sol(time_steps)[0], "b", label="Interpolated curve")
    ax.grid(visible=True)
    ax.set_ylabel("Temperature [K]", fontsize=10)
    ax.set_title("Quench temperature evolution", fontsize=11)
    ax.legend(fontsize=9)

    ax.tick_params(axis="y", labelcolor="k", labelsize=9)

    props = {"boxstyle": "round", "facecolor": "white", "alpha": 0.8}
    ax.text(
        0.65,
        0.5,
        result.info_text,
        transform=ax.transAxes,
        fontsize=9,
        verticalalignment="top",
        bbox=props,
    )
    ax.figure.tight_layout()


def plot_I_B(I_fun, B_fun, t0, tf, ax, n_steps=300):
    time_steps = np.linspace(t0, tf, n_steps)
    I_values = [I_fun(t) for t in time_steps]  # noqa: N806
    B_values = [B_fun(t) for t in time_steps]

    ax.plot(time_steps, I_values, "g", label="Current [A]")
    ax.set_ylabel("Current [A]", color="g", fontsize=10)
    ax.tick_params(axis="y", labelcolor="g", labelsize=9)
    ax.grid(visible=True)

    ax_right = ax.twinx()
    ax_right.plot(time_steps, B_values, "m--", label="Magnetic field [T]")
    ax_right.set_ylabel("Magnetic field [T]", color="m", fontsize=10)
    ax_right.tick_params(axis="y", labelcolor="m", labelsize=9)

    # Labels
    ax.set_xlabel("Time [s]", fontsize=10)
    ax.tick_params(axis="x", labelsize=9)

    # Combined legend for both sides
    lines, labels = ax.get_legend_handles_labels()
    lines2, labels2 = ax_right.get_legend_handles_labels()
    ax.legend(lines + lines2, labels + labels2, loc="best", fontsize=9)

    ax.figure.tight_layout()


def plot_summary(result, t0, tf, I_fun, B_fun, n_steps, show=False):
    f, (ax_temp, ax_ib) = plt.subplots(2, 1, figsize=(8, 8), sharex=True)
    plot_cable_temperature_evolution(result, t0, tf, ax_temp, n_steps)
    plot_I_B(I_fun, B_fun, t0, tf, ax_ib, n_steps * 3)
    return f
