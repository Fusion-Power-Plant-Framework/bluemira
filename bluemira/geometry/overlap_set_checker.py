import numpy as np


def two_set_mutually_exclusive(
    min_a: np.ndarray[float],
    max_a: np.ndarray[float],
    min_b: np.ndarray[float],
    max_b: np.ndarray[float],
) -> np.ndarray:
    """
    Given TWO lists of bounds, (e.g. x-bounds, i.e. x-min and x-max for each cell),
    find whether each cell is mutually exclusive (i.e. does NOT overlap) with other
    cells. This forms a 2D exclusivity matrix.

    Parameters
    ----------
    min_a:
        lower bound for each cell in set A, a 1D array.
    max_a:
        upper bound for each cell in set A, a 1D array.
    min_b:
        lower bound for each cell in set B, a 1D array.
    max_b:
        upper bound for each cell in set B, a 1D array.


    Returns
    -------
    :
        A 2D exclusivity matrix showing True where they're NOT overlapping, False if
        overlapping. The main-diagonal of this matrix can be ignored.

    Note
    ----
    Must have the property that all(min_a<=max_a) and all(min_b<=max_b).
    """
    len_a = len(min_a)
    len_b = len(min_b)
    matrix_min_a = np.broadcast_to(min_a, (len_b, len_a)).T
    matrix_max_a = np.broadcast_to(max_a, (len_b, len_a)).T
    matrix_min_b = np.broadcast_to(min_b, (len_a, len_b))
    matrix_max_b = np.broadcast_to(max_b, (len_a, len_b))
    return np.logical_or(matrix_max_a < matrix_min_b, matrix_min_a > matrix_max_b)


def check_two_sets_bb_non_interference(
    set_a_3d_tensor: np.ndarray, set_b_3d_tensor: np.ndarray
) -> np.ndarray:
    """
    Check which bounding box do not interfere/overlap with which other bounding box.

    Parameters
    ----------
    set_a_3d_tensor:
        An array of 2D arrays (each with shape = (3,2)), each row of the 2D array is
        the x, y, z bounds (min, max) for that cell.

    Returns
    -------
    exclusivity_matrix:
        A matrix of booleans showing whether the bounding boxes overlap.
    """
    x_bounds_a = set_a_3d_tensor[:, 0, :]
    y_bounds_a = set_a_3d_tensor[:, 1, :]
    z_bounds_a = set_a_3d_tensor[:, 2, :]

    x_bounds_b = set_b_3d_tensor[:, 0, :]
    y_bounds_b = set_b_3d_tensor[:, 1, :]
    z_bounds_b = set_b_3d_tensor[:, 2, :]

    return np.array([
        two_set_mutually_exclusive(*x_bounds_a, *x_bounds_b),
        two_set_mutually_exclusive(*y_bounds_a, *y_bounds_b),
        two_set_mutually_exclusive(*z_bounds_a, *z_bounds_b),
    ]).any(axis=0)


def get_overlaps_asymmetric(exclusivity_matrix) -> np.ndarray:
    """
    Get the indices of the bounding boxes that are overlapping. The overlap matrix is the
    element-wise negation of the exclusivity matrix. This function returns the 2-D
    indices of non-zero elements on the upper-right triangle of this matrix.

    Parameters
    ----------
    exclusivity_matrix:
        The matrix denoting whether each bounding box overlap with other bounding boxes,
        generated by check_bb_non_interference.

    Returns
    -------
    indices:
        2D array of integers, each row is a pair of indices of i<j
    """
    i, j = np.where(~exclusivity_matrix)
    return np.array([i, j]).T
