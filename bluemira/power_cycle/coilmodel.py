# generated by datamodel-codegen:
#   filename:  coilsupply_config.json
#   timestamp: 2025-05-05T10:40:34+00:00

from __future__ import annotations

import numpy as np
from pydantic import BaseModel, Field, NonNegativeFloat, RootModel, model_validator

from bluemira.utilities.tools import get_class_from_module


class PowerLossPercentages(RootModel):
    root: dict[str, float | int]


class ConverterConfig(BaseModel):
    class_name: str
    description: str
    max_bridge_voltage: float
    power_loss_percentages: PowerLossPercentages


class CoilSupplyConverter:
    """
    The power converter technology that computes the
    "wall-plug" power consumption by the coils supply system.
    """

    def __init__(self, description, max_bridge_voltage, power_loss_percentages):
        self.description = description
        self.max_bridge_voltage = max_bridge_voltage
        self.power_loss_percentages = power_loss_percentages


class ThyristorBridges(CoilSupplyConverter):
    """
    Representation of power converter systems using Thyristor Bridges.

    This simplified model computes reactive power loads but does not
    account for power electronics dynamics and its associated control
    systems; it also neglects the following effects:
        - reductions allowed by sequential control of series-connects
            unit (as foreseen in ITER);
        - current circulation mode between bridges connects in parallel
            (since it is only expected at low currents, when reactive
            power is also low);
        - voltage drops in the transformer itself;
        - other non-linearities.
    """

    def compute_conversion(self, voltages_array, currents_array):
        """
        Compute power loads required by converter to feed coils.

        Parameters
        ----------
        voltage: np.ndarray
            Array of voltages in time. [V]
        current: np.ndarray
            Array of currents in time. [A]
        """
        loss_percentages = self.power_loss_percentages
        v_max_bridge = self.max_bridge_voltage
        v_max_coil = np.max(np.absolute(voltages_array))
        if v_max_coil == 0:
            raise ValueError(
                "Voltage array must contain at least one value",
                "different than zero.",
            )
        number_of_bridge_units = np.ceil(v_max_coil / v_max_bridge)
        v_rated = number_of_bridge_units * v_max_bridge
        i_rated = max(currents_array)
        p_rated = v_rated * i_rated  # Probably wrong (maxV * maxI â‰  max power)

        p_apparent = v_rated * currents_array
        power_factor = voltages_array / v_rated
        phase_rad = np.arccos(power_factor)
        phase_deg = phase_rad * 180 / np.pi

        p_active = voltages_array * currents_array
        # p_active = p_apparent * np.cos(phase_rad)

        p_reactive = np.absolute(p_apparent) * np.sin(phase_rad)
        # p_reactive = np.sqrt(np.square(p_apparent) - np.square(p_active))

        p_loss_multiplier = 1
        for percentage in loss_percentages.root:
            p_loss_multiplier *= 1 + loss_percentages.root[percentage] / 100
        p_losses = p_loss_multiplier * p_active
        p_active += p_losses

        return {
            f"{self.name}_voltages": voltages_array,
            f"{self.name}_currents": currents_array,
            "number_of_bridge_units": number_of_bridge_units,
            "voltage_rated": v_rated,
            "current_rated": i_rated,
            "power_rated": p_rated,
            "power_apparent": p_apparent,
            "phase_radians": phase_rad,
            "phase_degrees": phase_deg,
            "power_factor": power_factor,
            "power_losses": p_losses,
            "power_active": p_active,
            "power_reactive": p_reactive,
        }


class ConverterLibrary(RootModel):
    root: dict[str, CoilSupplyConverter]

    @model_validator(mode="before")
    def _(self):
        for k, v in self.items():
            conv = ConverterConfig(**v)

            self[k] = get_class_from_module(
                conv.class_name, default_module="bluemira.powercycle.coilmodel"
            )(conv.description, conv.max_bridge_voltage, conv.power_loss_percentages)
        return self


class Resistance(BaseModel):
    value: NonNegativeFloat
    unit: str = "ohm"

    @model_validator(mode="before")
    def unit_validator(self):
        if not isinstance(self, dict):
            return {"value": self}
        return self


class Corrector(BaseModel):
    description: str
    resistance_set: Resistance | dict[str, Resistance]


class CoilSupplyCorrector:
    """
    Safety and auxiliary sub-systems for coil power supply systems.

    Class to represent safety and auxiliary sub-systems of a
    'CoilSupplySystem' object, that result in a partial voltage
    reduction due to an equivalent resistance.

    Parameters
    ----------
    config: CoilSupplyCorrectorConfig
        Object that characterizes a 'CoilSupplyCorrector' instance.
    """

    def __init__(self, description: str, resistance_set: dict[str, Resistance]):
        self.description = description
        self.resistance_set = resistance_set

    def compute_correction(
        self,
        voltages_parameter,
        currents_parameter,
        switches_parameter,
    ):
        """
        Apply a correction due to the presence of a corrector
        in coil circuits.

        Given the demanded voltages and currents, compute the effect
        of the corrector to each attribute of the parameters.

        As a first approximation, neglect current reduction due to
        resistance of corrector device, and reduce total voltage
        by contribution to resistance connected in series.

        TODO this should be rewritten. Bad things:
        - Custom copy
        - overuse of get and setattr
        """
        voltages_corrector = voltages_parameter.duplicate()
        currents_corrector = currents_parameter.duplicate()

        voltages_following = voltages_parameter.duplicate()
        currents_following = currents_parameter.duplicate()
        for name in self.resistance_set:
            requested_v = getattr(voltages_parameter, name)
            requested_i = getattr(currents_parameter, name)
            corrector_s = getattr(switches_parameter, name)

            corrector_resistance = self.resistance_set[name]
            corrector_i = requested_i
            corrector_v = -corrector_resistance * corrector_i
            if corrector_s is not None:
                corrector_i = np.multiply(corrector_i, corrector_s)
                corrector_v = np.multiply(corrector_v, corrector_s)
            setattr(voltages_corrector, name, corrector_v)
            setattr(currents_corrector, name, corrector_i)

            following_v = requested_v - corrector_v
            following_i = requested_i
            setattr(voltages_following, name, following_v)
            setattr(currents_following, name, following_i)

        return (
            voltages_following,
            currents_following,
            voltages_corrector,
            currents_corrector,
        )


class CorrectorLibrary(RootModel):
    root: dict[str, CoilSupplyCorrector]

    @model_validator(mode="before")
    def _(self):
        for k, v in self.items():
            corr = Corrector(**v)
            self[k] = CoilSupplyCorrector(corr.description, corr.resistance_set)
        return self


class CoilSupply(BaseModel):
    description: str
    coil_names: list = Field(default_factory=list)
    corrector_technologies: list[str] = Field(default_factory=list)
    converter_technology: str | None = None
    corrector_library: CorrectorLibrary
    converter_library: ConverterLibrary
