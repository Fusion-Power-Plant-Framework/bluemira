# SPDX-FileCopyrightText: 2021-present M. Coleman, J. Cook, F. Franza
# SPDX-FileCopyrightText: 2021-present I.A. Maione, S. McIntosh
# SPDX-FileCopyrightText: 2021-present J. Morris, D. Short
#
# SPDX-License-Identifier: LGPL-2.1-or-later

"""
Example script demonstrating the use of the Bluemira WP and TF coil modules
for conductor design, thermal and structural optimization, and case layout visualization.
"""

# %% md
# # This is an example that shows the application of the WP module for the TF coils
# %% md
# ## Some import
# %%
from dataclasses import dataclass
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np

from bluemira.base.constants import MU_0, MU_0_2PI, MU_0_4PI
from bluemira.base.file import get_bluemira_path
from bluemira.base.look_and_feel import bluemira_print
from bluemira.magnets.cable import (
    ABCCable,
    DummyRectangularCableLTS,
)
from bluemira.magnets.case_tf import BaseCaseTF, TrapezoidalCaseTF
from bluemira.magnets.conductor import Conductor, SymmetricConductor
from bluemira.magnets.init_magnets_registry import register_all_magnets
from bluemira.magnets.strand import (
    Strand,
    SuperconductingStrand,
    create_strand_from_dict,
)
from bluemira.magnets.utils import (
    delayed_exp_func,
)
from bluemira.magnets.winding_pack import WindingPack
from bluemira.materials import MaterialCache

# %%
# cache all the magnets classes for future use
register_all_magnets()

# load supporting bluemira materials
MATERIAL_DATA_PATH = get_bluemira_path("magnets", subfolder="examples")
MATERIAL_CACHE = MaterialCache()
MATERIAL_CACHE.load_from_file(Path(MATERIAL_DATA_PATH, "materials_mag.json"))

# get some materials from MATERIAL_CACHE
ss316 = MATERIAL_CACHE.get_material("SS316-LN")
nb3sn = MATERIAL_CACHE.get_material("Nb3Sn - WST")
copper100 = MATERIAL_CACHE.get_material("Copper100")
copper300 = MATERIAL_CACHE.get_material("Copper300")
dummy_insulator = MATERIAL_CACHE.get_material("DummyInsulator")
# %% md
# ## Plot options
# %%
# Enable interactive mode
# %matplotlib notebook

show = True
homogenized = False
# %% md
#
# ## Input (and derived) values
# *Note: these values shall be provided internally by bluemira code (as reactor
# settings or as information coming from the TF coils builder)<br><br>
#
# **Machine (generic)**
# %%
R0 = 8.6  # [m] major machine radius
B0 = 4.39  # [T] magnetic field @R0
A = 2.8  # machine aspect ratio
n_TF = 16  # number of TF coils
ripple = 6e-3  # requirement on the maximum plasma ripple

a = R0 / A  # minor radius
# %% md
# **Inputs for the TF coils**
# %%
d = 1.82  # additional distance to calculate the max external radius of the inner TF leg
Iop = 70.0e3  # operational current in each conductor
dr_plasma_side = R0 * 2 / 3 * 1e-2  # thickness of the plate before the WP
T_sc = 4.2  # operational temperature of superconducting cable
T_margin = 1.5  # temperature margin
T_op = T_sc + T_margin  # temperature considered for the superconducting cable
t_delay = 3  # [s]
hotspot_target_temperature = 250.0  # [K]

Ri = R0 - a - d  # [m] max external radius of the internal TF leg
Re = (R0 + a) * (1 / ripple) ** (
    1 / n_TF
)  # [m] max internal radius of the external TF leg
I_TF = B0 * R0 / MU_0_2PI / n_TF  # total current in each TF coil


# magnetic field generated by the TF coils with a correction factor that takes into
# account the ripple
def B_TF_r(I_TF, n_TF, r):
    """
    Compute the magnetic field generated by the TF coils, including ripple correction.

    Parameters
    ----------
    I_TF : float
        Toroidal field coil current [A].
    n_TF : int
        Number of toroidal field coils.
    r : float
        Radial position from the tokamak center [m].

    Returns
    -------
    float
        Magnetic field intensity [T].
    """
    return 1.08 * (MU_0_2PI * n_TF * I_TF / r)


# max magnetic field on the inner TF leg
B_TF_i = B_TF_r(I_TF, n_TF, Ri)
# magnetic pressure on the inner TF leg
pm = B_TF_i**2 / (2 * MU_0)

# vertical tension acting on the equatorial section of inner TF leg
# i.e. half of the whole F_Z
t_z = 0.5 * np.log(Re / Ri) * MU_0_4PI * n_TF * I_TF**2

n_cond = np.floor(I_TF / Iop)  # minimum number of conductors
bluemira_print(f"Total number of conductor: {n_cond}")
# %% md
# ***Additional data***
# %%
R_VV = Ri * 1.05  # Vacuum vessel radius
S_VV = 100e6  # Vacuum vessel steel limit

# allowable stress values
safety_factor = 1.5 * 1.3
S_Y = 1e9 / safety_factor  # [Pa] steel allowable limit

# %% md
# ## Calculation of the maximum discharge time for the TF coils
# %%
# inductance (here approximated... better estimation in bluemira)
L = MU_0 * R0 * (n_TF * n_cond) ** 2 * (1 - np.sqrt(1 - (R0 - Ri) / R0)) / n_TF * 1.1

# Maximum tension... (empirical formula from Lorenzo... find a generic equation)
V_MAX = (7 * R0 - 3) / 6 * 1.1e3
# Discharge characteristic times
Tau_discharge1 = L * Iop / V_MAX
Tau_discharge2 = B0 * I_TF * n_TF * (R0 / A) ** 2 / (R_VV * S_VV)
# Discharge characteristic time to be considered in the following
tau_discharge = max([Tau_discharge1, Tau_discharge2])

bluemira_print(f"Maximum TF discharge time: {tau_discharge}")
# %% md
# ## Current and magnetic field behaviour during discharge
#
# %%
I_fun = delayed_exp_func(Iop, tau_discharge, t_delay)
B_fun = delayed_exp_func(B_TF_i, tau_discharge, t_delay)


# %% md
# ### Define materials (at the beginning the conductor is defined with a dummy number
# of stabilizer strands)
# %%
# create the strand
# Define strand configurations as dictionaries
sc_strand_dict = {
    "name_in_registry": "SuperconductingStrand",
    "name": "Nb3Sn_strand",
    "d_strand": 1.0e-3,
    "temperature": T_op,
    "materials": [
        {"material": "Nb3Sn - WST", "fraction": 0.5},
        {"material": "Copper100", "fraction": 0.5},
    ],
}

stab_strand_dict = {
    "name_in_registry": "Strand",
    "name": "Stabilizer",
    "d_strand": 1.0e-3,
    "temperature": T_op,
    "materials": [{"material": "Copper300", "fraction": 1.0}],
}

# Create strand objects using class-based factory methods
sc_strand = create_strand_from_dict(name="Nb3Sn_strand", strand_dict=sc_strand_dict)
stab_strand = create_strand_from_dict(name="Stabilizer", strand_dict=stab_strand_dict)


dx = 0.05  # cable length... just a dummy value

cable = DummyRectangularCableLTS(
    dx=dx,
    sc_strand=None,
    stab_strand=None,
    n_sc_strand=None,
    n_stab_strand=None,
    d_cooling_channel=1e-2,
    void_fraction=0.7,
    cos_theta=0.97,
)


# %% md
#
# %% md
# ***Change cable aspect ratio***
# %%
aspect_ratio = 1.2
cable.set_aspect_ratio(
    aspect_ratio
)  # This adjusts the cable dimensions while maintaining the total cross-sectional area.

# %%
###########################################################
# Create a conductor with the specified cable
conductor = SymmetricConductor(
    cable=None,
    mat_jacket=ss316,
    mat_ins=dummy_insulator,
    dx_jacket=0.01,
    dx_ins=1e-3,
)

# %%
# case parameters
layout = "auto"  # "layer" or "pancake"
wp_reduction_factor = 0.75
min_gap_x = 2 * dr_plasma_side
n_layers_reduction = 4

case = TrapezoidalCaseTF.my_init(
    Ri=Ri,
    dy_ps=dr_plasma_side,
    dy_vault=0.7,
    theta_TF=360 / n_TF,
    mat_case=ss316,
)


@dataclass
class TFWPDesignerParams:
    R0 = 8.6  # [m] major machine radius
    B0 = 4.39  # [T] magnetic field @R0
    A = 2.8  # machine aspect ratio
    n_TF = 16  # number of TF coils
    ripple = 6e-3  # requirement on the maximum plasma ripple
    d = 1.82  # additional distance to calculate the max external radius of the inner TF leg
    Iop = 70.0e3  # operational current in each conductor
    T_sc = 4.2  # operational temperature of superconducting cable
    T_margin = 1.5  # temperature margin
    tau_discharge = tau_discharge
    t_delay = 3  # [s]
    hotspot_target_temperature = 250.0  # [K]

    # Case / WP geometry tuning
    layout = "auto"  # "layer" or "pancake"
    wp_reduction_factor = 0.75
    n_layers_reduction = 4


@dataclass
class DerivedParams:
    a: float  # plasma minor radius [m]
    dr_plasma_side: float  # thickness of the plate before the WP
    min_gap_x: float
    r_i: float  # [m] max external radius of the internal TF leg
    r_e: float  # [m] max internal radius of the external TF leg
    i_tf: float  # total current in each TF coil
    n_conductors: int  # Total number of conductors in the WP
    t_op: float  # temperature considered for the superconducting cable
    peak_field: float  # Peak field in the TW WP [T]
    magnetic_pressure: (
        float  # magnetic pressure on the inner TF leg = B_TF_i**2 / (2 * MU_0)
    )
    vertical_tension: float  # vertical tension acting on the equatorial section of inner TF leg i.e. half of the whole F_Z


class TFWPDataStructure:
    def __init__(
        self,
        sc_strand: SuperconductingStrand,
        stabiliser: Strand,
        cable: ABCCable,
        conductor: Conductor,
        case: BaseCaseTF,
        params: TFWPDesignerParams,
    ):
        self.params = params
        self._derive_params(params)

        critical_strand_current = sc_strand.Ic(
            B=self.derived_params.peak_field, temperature=self.derived_params.t_op
        )
        n_sc_strand = int(np.ceil(self.params.Iop / critical_strand_current))

        cable.set_strands(sc_strand, stabiliser)
        cable.n_sc_strand = n_sc_strand
        conductor.set_cable(cable)
        wp1 = WindingPack(conductor, 1, 1, name=None)
        self.case = case
        self.case.set_wp([wp1])
        self.case.rearrange_conductors_in_wp(
            n_conductors=self.derived_params.n_conductors,
            wp_reduction_factor=params.wp_reduction_factor,
            min_gap_x=self.derived_params.min_gap_x,
            n_layers_reduction=params.n_layers_reduction,
            layout=params.layout,
        )

        ax = self.case.plot(show=False, homogenized=False)
        ax.set_title("Case design before optimization")
        plt.show()

    def _derive_params(self, params):
        a = params.R0 / params.A
        dr_plasma_side = params.R0 * 2 / 3 * 1e-2
        i_tf = params.B0 * params.R0 / MU_0_2PI / params.n_TF
        r_i = params.R0 - a - params.d
        r_e = (params.R0 + a) * (1 / params.ripple) ** (1 / params.n_TF)
        peak_field = B_TF_r(i_tf, params.n_TF, r_i)
        magnetic_pressure = peak_field**2 / (2 * MU_0)
        t_z = 0.5 * np.log(r_e / r_i) * MU_0_4PI * params.n_TF * i_tf**2

        self.derived_params = DerivedParams(
            params.R0 / params.A,
            dr_plasma_side,
            2.0 * dr_plasma_side,
            r_i,
            r_e,
            i_tf,
            n_conductors=np.floor(i_tf / params.Iop),
            t_op=params.T_sc + params.T_margin,
            peak_field=peak_field,
            magnetic_pressure=magnetic_pressure,
            vertical_tension=t_z,
        )


print(f"pre-wp reduction factor: {wp_reduction_factor}")

# arrangement of conductors into the winding pack and case
case.rearrange_conductors_in_wp(
    n_conductors=n_cond,
    wp_reduction_factor=wp_reduction_factor,
    min_gap_x=min_gap_x,
    n_layers_reduction=n_layers_reduction,
    layout=layout,
)

ax = case.plot(show=False, homogenized=False)
ax.set_title("Case design before optimization")
plt.show()

bluemira_print(f"Previous number of conductors: {n_cond}")
bluemira_print(f"New number of conductors: {case.n_conductors}")

# %% md
# ## Optimize cable jacket and case vault thickness
# %%
# Optimization parameters
bounds_cond_jacket = np.array([1e-5, 0.2])
bounds_dy_vault = np.array([0.1, 2])
max_niter = 100
err = 1e-6

# case.optimize_jacket_and_vault(
case.optimize_jacket_and_vault(
    pm=pm,
    fz=t_z,
    temperature=T_op,
    B=B_TF_i,
    allowable_sigma=S_Y,
    bounds_cond_jacket=bounds_cond_jacket,
    bounds_dy_vault=bounds_dy_vault,
    layout=layout,
    wp_reduction_factor=wp_reduction_factor,
    min_gap_x=min_gap_x,
    n_layers_reduction=n_layers_reduction,
    max_niter=max_niter,
    eps=err,
    n_conds=n_cond,
)

# %%
# new operational current
bluemira_print(f"Operational current after optimization: {I_TF / case.n_conductors}")

case.plot_convergence()
