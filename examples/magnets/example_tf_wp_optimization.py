# SPDX-FileCopyrightText: 2021-present M. Coleman, J. Cook, F. Franza
# SPDX-FileCopyrightText: 2021-present I.A. Maione, S. McIntosh
# SPDX-FileCopyrightText: 2021-present J. Morris, D. Short
#
# SPDX-License-Identifier: LGPL-2.1-or-later

"""
Example script demonstrating the use of the Bluemira WP and TF coil modules
for conductor design, thermal and structural optimization, and case layout visualization.
"""

# %% md
# # This is an example that shows the application of the WP module for the TF coils
# %% md
# ## Some import
# %%

import matplotlib.pyplot as plt
import numpy as np
from eurofusion_materials.library.magnet_branch_mats import (
    COPPER_100,
    COPPER_300,
    DUMMY_INSULATOR_MAG,
    NB3SN_MAG,
    SS316_LN_MAG,
)
from matplotlib import cm

# get some materials from EUROfusion materials library
from matproplib import OperationalConditions

from bluemira.base.constants import MU_0, MU_0_2PI, MU_0_4PI
from bluemira.base.look_and_feel import bluemira_print
from bluemira.magnets.cable import RectangularCable
from bluemira.magnets.case_tf import TrapezoidalCaseTF
from bluemira.magnets.conductor import SymmetricConductor
from bluemira.magnets.init_magnets_registry import register_all_magnets
from bluemira.magnets.strand import create_strand_from_dict
from bluemira.magnets.utils import (
    delayed_exp_func,
)
from bluemira.magnets.winding_pack import WindingPack

# %%
# cache all the magnets classes for future use
register_all_magnets()


# %% md
# ## Plot options
# %%
# Enable interactive mode
# %matplotlib notebook

show = True
homogenized = False
# %% md
#
# ## Input (and derived) values
# *Note: these values shall be provided internally by bluemira code (as reactor
# settings or as information coming from the TF coils builder)<br><br>
#
# **Machine (generic)**
# %%
R0 = 8.6  # [m] major machine radius
B0 = 4.39  # [T] magnetic field @R0
A = 2.8  # machine aspect ratio
n_TF = 16  # number of TF coils
ripple = 6e-3  # requirement on the maximum plasma ripple

a = R0 / A  # minor radius
# %% md
# **Inputs for the TF coils**
# %%
d = 1.82  # additional distance to calculate the max external radius of the inner TF leg
Iop = 70.0e3  # operational current in each conductor
dr_plasma_side = R0 * 2 / 3 * 1e-2  # thickness of the plate before the WP
T_sc = 4.2  # operational temperature of superconducting cable
T_margin = 1.5  # temperature margin
T_op = T_sc + T_margin  # temperature considered for the superconducting cable
t_delay = 3  # [s]
t0 = 0  # [s]
hotspot_target_temperature = 250.0  # [K]

Ri = R0 - a - d  # [m] max external radius of the internal TF leg
Re = (R0 + a) * (1 / ripple) ** (
    1 / n_TF
)  # [m] max internal radius of the external TF leg
I_TF = B0 * R0 / MU_0_2PI / n_TF  # total current in each TF coil


# magnetic field generated by the TF coils with a correction factor that takes into
# account the ripple
def B_TF_r(I_TF, n_TF, r):
    """
    Compute the magnetic field generated by the TF coils, including ripple correction.

    Parameters
    ----------
    I_TF : float
        Toroidal field coil current [A].
    n_TF : int
        Number of toroidal field coils.
    r : float
        Radial position from the tokamak center [m].

    Returns
    -------
    float
        Magnetic field intensity [T].
    """
    return 1.08 * (MU_0_2PI * n_TF * I_TF / r)


# max magnetic field on the inner TF leg
B_TF_i = B_TF_r(I_TF, n_TF, Ri)
# magnetic pressure on the inner TF leg
pm = B_TF_i**2 / (2 * MU_0)

# vertical tension acting on the equatorial section of inner TF leg
# i.e. half of the whole F_Z
t_z = 0.5 * np.log(Re / Ri) * MU_0_4PI * n_TF * I_TF**2

n_cond = np.floor(I_TF / Iop)  # minimum number of conductors
bluemira_print(f"Total number of conductor: {n_cond}")
# %% md
# ***Additional data***
# %%
R_VV = Ri * 1.05  # Vacuum vessel radius
S_VV = 100e6  # Vacuum vessel steel limit

# allowable stress values
safety_factor = 1.5 * 1.3
S_Y = 1e9 / safety_factor  # [Pa] steel allowable limit

# %% md
# ## Calculation of the maximum discharge time for the TF coils
# %%
# inductance (here approximated... better estimation in bluemira)
L = MU_0 * R0 * (n_TF * n_cond) ** 2 * (1 - np.sqrt(1 - (R0 - Ri) / R0)) / n_TF * 1.1
# Magnetic energy
Wm = 1 / 2 * L * n_TF * Iop**2 * 1e-9
# Maximum tension... (empirical formula from Lorenzo... find a generic equation)
V_MAX = (7 * R0 - 3) / 6 * 1.1e3
# Discharge characteristic times
Tau_discharge1 = L * Iop / V_MAX
Tau_discharge2 = B0 * I_TF * n_TF * (R0 / A) ** 2 / (R_VV * S_VV)
# Discharge characteristic time to be considered in the following
Tau_discharge = max([Tau_discharge1, Tau_discharge2])
tf = Tau_discharge
bluemira_print(f"Maximum TF discharge time: {tf}")
# %% md
# ## Current and magnetic field behaviour during discharge
#
# %%
I_fun = delayed_exp_func(Iop, Tau_discharge, t_delay)
B_fun = delayed_exp_func(B_TF_i, Tau_discharge, t_delay)

# Create a time array from 0 to 3*Tau_discharge
t = np.linspace(0, 3 * Tau_discharge, 500)
I_data = np.array([I_fun(t_i) for t_i in t])
B_data = np.array([B_fun(t_i) for t_i in t])

# Create a figure and axis
fig, ax1 = plt.subplots()

# Plot I_fun
ax1.plot(t, I_data, "b-o", label="Current (I)", markevery=30)
ax1.set_xlabel("Time [s]")
ax1.set_ylabel("Current (I) [A]", color="b")
ax1.tick_params("y", colors="b")

# Create a twin y-axis for the magnetic field B
ax2 = ax1.twinx()
ax2.plot(t, B_data, "r:s", label="Magnetic Field (B)", markevery=30)
ax2.set_ylabel("Magnetic Field (B) [T]", color="r")
ax2.tick_params("y", colors="r")

# Add grid and title
ax1.grid(visible=True)
plt.title("Current (I) and Magnetic Field (B) vs Time")

# Show the plot
plt.show()
# %% md
# ### Define materials (at the beginning the conductor is defined with a dummy number
# of stabilizer strands)
# %%
# create the strand
# Define strand configurations as dictionaries
sc_strand_dict = {
    "name_in_registry": "SuperconductingStrand",
    "name": "Nb3Sn_strand",
    "d_strand": 1.0e-3,
    "temperature": T_op,
    "materials": [
        {"material": NB3SN_MAG, "fraction": 0.5},
        {"material": COPPER_100, "fraction": 0.5},
    ],
}

stab_strand_dict = {
    "name_in_registry": "Strand",
    "name": "Stabilizer",
    "d_strand": 1.0e-3,
    "temperature": T_op,
    "materials": [{"material": COPPER_300, "fraction": 1.0}],
}

# Create strand objects using class-based factory methods
sc_strand = create_strand_from_dict(name="Nb3Sn_strand", strand_dict=sc_strand_dict)
stab_strand = create_strand_from_dict(name="Stabilizer", strand_dict=stab_strand_dict)

# plot the critical current in a range of B between [10,16]
Bt_arr = np.linspace(10, 16, 100)
sc_strand.plot_Ic_B(Bt_arr, temperature=(T_sc + T_margin))

# %% md
# #### Plot number of conductor vs Iop
# %%
# Define the range of operating current (Iop) values
Iop_range = (
    np.linspace(30, 100, 100) * 1e3
)  # 5 equally spaced values between 30 and 100 A
op_conds = [
    OperationalConditions(temperature=T_sc + T_margin, magnetic_field=Bti)
    for Bti in Bt_arr
]
Ic_sc_arr = np.array([sc_strand.Ic(op) for op in op_conds])

# Create a colormap to assign colors to different Iop values
colors = cm.viridis(np.linspace(0, 1, len(Iop_range)))  # Use the 'viridis' colormap

# Create a figure and axis
fig, ax = plt.subplots()

# Plot the number of superconducting strands as a function of B for different Iop values
for Iop_ref, color in zip(Iop_range, colors, strict=False):
    n_sc_strand = Iop_ref / Ic_sc_arr  # Calculate number of strands
    ax.plot(Bt_arr, n_sc_strand, color=color, label=f"Iop = {Iop} A")
    # Add plot title, axis labels, and grid
ax.set_title("Number of strands as function of B and Iop")  # Title
ax.set_xlabel("B [T]")  # X-axis label
ax.set_ylabel("Nc strands")  # Y-axis label
ax.grid(visible=True)

# Create a ScalarMappable to map colors to the colorbar
sm = plt.cm.ScalarMappable(
    cmap="viridis", norm=plt.Normalize(vmin=Iop_range.min(), vmax=Iop_range.max())
)
sm.set_array([])  # Dummy array for the ScalarMappable

# Add the colorbar to the figure
cbar = fig.colorbar(sm, ax=ax)
cbar.set_label("Iop [A]")  # Label the colorbar

# Show the plot
plt.show()

# %% md
# **Calculate number of superconducting strands considering the strand critical
# current at B_TF_i and T_sc + T_margin**
# %%
op_cond = OperationalConditions(temperature=T_op, magnetic_field=B_TF_i)
Ic_sc = sc_strand.Ic(op_cond)
n_sc_strand = int(np.ceil(Iop / Ic_sc))

###########################################################
dx = 0.05  # cable length... just a dummy value
B_ref = 15  # [T] Reference B field value (limit for LTS)

if B_TF_i < B_ref:
    cable = RectangularCable(
        name="RectangularCableLTS",
        dx=dx,
        sc_strand=sc_strand,
        stab_strand=stab_strand,
        n_sc_strand=n_sc_strand,
        n_stab_strand=500,
        d_cooling_channel=1e-2,
        void_fraction=0.7,
        cos_theta=0.97,
        E=0.1e9,
    )
else:
    cable = RectangularCable(
        name="RectangularCableHTS",
        dx=dx,
        sc_strand=sc_strand,
        stab_strand=stab_strand,
        n_sc_strand=n_sc_strand,
        n_stab_strand=500,
        d_cooling_channel=1e-2,
        void_fraction=0.7,
        cos_theta=0.97,
        E=120e9,
    )
cable.plot(0, 0, show=True)
bluemira_print(f"cable area: {cable.area}")
# %% md
#
# %% md
# ***Change cable aspect ratio***
# %%
aspect_ratio = 1.2
# This adjusts the cable dimensions while maintaining the total cross-sectional area.
cable.aspect_ratio = aspect_ratio
cable.plot(0, 0, show=True)
bluemira_print(f"cable area: {cable.area}")

# operational_point = {"temperature": 5.7, "B": B(0)}

mats = [NB3SN_MAG, COPPER_100, COPPER_300, SS316_LN_MAG]
mat_names = ["nb3sn", "copper100", "copper300", "ss316"]
temperatures = np.linspace(5, 250, 500)
magnetic_field = B_fun(0)

# Prepare plots
# Adjusted for 5 plots (3x2 grid)
fig, axes = plt.subplots(3, 2, figsize=(12, 15))
fig.suptitle("Material Properties vs Temperature", fontsize=16)

ax1, ax2, ax3, ax4, ax5 = axes.flatten()[:5]  # Extracting the first five axes

for mat, name in zip(mats, mat_names, strict=False):
    # Calculate properties over the temperature range
    op_conds = [
        OperationalConditions(temperature=T, magnetic_field=magnetic_field)
        for T in temperatures
    ]
    density = np.array([mat.density(op) for op in op_conds])
    cp_per_mass = np.array([mat.specific_heat_capacity(op) for op in op_conds])
    cp_per_volume = cp_per_mass * density
    erho = np.array([mat.electrical_resistivity(op) for op in op_conds])
    E = np.array([mat.youngs_modulus(op) for op in op_conds])

    # Plot density
    ax1.plot(temperatures, density, label=name)
    # Plot Cp [J/Kg/K]
    ax2.plot(temperatures, cp_per_mass, label=name)
    # Plot Cp [J/K/m³]
    ax3.plot(temperatures, cp_per_volume, label=name)
    # Plot erho [Ohm m]
    ax4.plot(temperatures, erho, label=name)
    # Plot E (assuming Young's modulus)
    ax5.plot(temperatures, E, label=name)

# Configure plots
ax1.set_title("Density [kg/m³] vs Temperature")
ax1.set_xlabel("Temperature [K]")
ax1.set_ylabel("Density [kg/m³]")
ax1.legend()
ax1.grid(visible=True)

ax2.set_title("Heat Capacity per Mass [J/Kg/K] vs Temperature")
ax2.set_xlabel("Temperature [K]")
ax2.set_ylabel("Cp [J/Kg/K]")
ax2.legend()
ax2.grid(visible=True)

ax3.set_title("Heat Capacity per Volume [J/K/m³] vs Temperature")
ax3.set_xlabel("Temperature [K]")
ax3.set_ylabel("Cp [J/K/m³]")
ax3.legend()
ax3.grid(visible=True)

ax4.set_title("Electrical Resistivity [Ohm·m] vs Temperature")
ax4.set_xlabel("Temperature [K]")
ax4.set_ylabel("Resistivity [Ohm·m]")
ax4.legend()
ax4.grid(visible=True)

ax5.set_title("E vs Temperature")  # Modify title according to the meaning of E
ax5.set_xlabel("Temperature [K]")
ax5.set_ylabel("E [Unit]")  # Change to correct unit
ax5.legend()
ax5.grid(visible=True)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

# %%
# optimize the number of stabilizer strands using the hot spot criteria.
# Note: optimize_n_stab_ths changes adjust cable.dy while maintaining cable.dx. It
# could be possible to add a parameter maintain constant the aspect ratio if
# necessary.
bluemira_print(
    f"before optimization: dx_cable = {cable.dx}, aspect ratio = {cable.aspect_ratio}"
)
T_for_hts = T_op
result = cable.optimize_n_stab_ths(
    t0,
    tf,
    T_for_hts,
    hotspot_target_temperature,
    B_fun,
    I_fun,
    bounds=[1, 10000],
    show=show,
)
bluemira_print(
    f"after optimization: dx_cable = {cable.dx}, aspect ratio = {cable.aspect_ratio}"
)

cable.set_aspect_ratio(aspect_ratio)
bluemira_print(
    f"Adjust aspect ratio: dx_cable = {cable.dx}, aspect ratio = {cable.aspect_ratio}"
)

# %%
###########################################################
# Create a conductor with the specified cable
conductor = SymmetricConductor(
    cable=cable,
    mat_jacket=SS316_LN_MAG,
    mat_ins=DUMMY_INSULATOR_MAG,
    dx_jacket=0.01,
    dx_ins=1e-3,
)

# %%
# case parameters
layout = "auto"  # "layer" or "pancake"
wp_reduction_factor = 0.75
min_gap_x = 2 * dr_plasma_side
n_layers_reduction = 4

# creation of the case
wp1 = WindingPack(conductor, 1, 1, name=None)  # just a dummy WP to create the case

case = TrapezoidalCaseTF(
    Ri=Ri,
    dy_ps=dr_plasma_side,
    dy_vault=0.7,
    theta_TF=360 / n_TF,
    mat_case=SS316_LN_MAG,
    wps=[wp1],
)

print(f"pre-wp reduction factor: {wp_reduction_factor}")

# arrangement of conductors into the winding pack and case
case.rearrange_conductors_in_wp(
    n_conductors=n_cond,
    wp_reduction_factor=wp_reduction_factor,
    min_gap_x=min_gap_x,
    n_layers_reduction=n_layers_reduction,
    layout=layout,
)

ax = case.plot(show=False, homogenized=False)
ax.set_title("Case design before optimization")
plt.show()

bluemira_print(f"Previous number of conductors: {n_cond}")
bluemira_print(f"New number of conductors: {case.n_conductors}")

# %% md
# ## Optimize cable jacket and case vault thickness
# %%
# Optimization parameters
bounds_cond_jacket = np.array([1e-5, 0.2])
bounds_dy_vault = np.array([0.1, 2])
max_niter = 100
err = 1e-6

# case.optimize_jacket_and_vault(
case.optimize_jacket_and_vault(
    pm=pm,
    fz=t_z,
    op_cond=OperationalConditions(temperature=T_op, magnetic_field=B_TF_i),
    allowable_sigma=S_Y,
    bounds_cond_jacket=bounds_cond_jacket,
    bounds_dy_vault=bounds_dy_vault,
    layout=layout,
    wp_reduction_factor=wp_reduction_factor,
    min_gap_x=min_gap_x,
    n_layers_reduction=n_layers_reduction,
    max_niter=max_niter,
    eps=err,
    n_conds=n_cond,
)

if show:
    scalex = np.array([2, 1])
    scaley = np.array([1, 1.2])

    ax = case.plot(homogenized=homogenized)
    ax.set_aspect("equal")

    # Fix the x and y limits
    ax.set_xlim(-scalex[0] * case.dx_i, scalex[1] * case.dx_i)
    ax.set_ylim(scaley[0] * 0, scaley[1] * case.Ri)

    deltax = [-case.dx_i / 2, case.dx_i / 2]

    ax.plot([-scalex[0] * case.dx_i, -case.dx_i / 2], [case.Ri, case.Ri], "k:")

    for i in range(len(case.wps)):
        ax.plot(
            [-scalex[0] * case.dx_i, -case.dx_i / 2],
            [case.R_wp_i[i], case.R_wp_i[i]],
            "k:",
        )

    ax.plot(
        [-scalex[0] * case.dx_i, -case.dx_i / 2],
        [case.R_wp_k[-1], case.R_wp_k[-1]],
        "k:",
    )
    ax.plot([-scalex[0] * case.dx_i, -case.dx_i / 2], [case.Rk, case.Rk], "k:")

    ax.set_title("Equatorial cross section of the TF WP")
    ax.set_xlabel("Toroidal direction [m]")
    ax.set_ylabel("Radial direction [m]")

    plt.show()


bluemira_print("Convergence should be: 9.066682976310327e-07 after 68 iterations")
# %%
# new operational current
bluemira_print(f"Operational current after optimization: {I_TF / case.n_conductors}")

case.plot_convergence()
